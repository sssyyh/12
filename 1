(*modified on 05/6/2017*)
GetReal[c_] := 
  N[IntegerPart[c*10^Naccu]/10^Naccu, Naccu] /; NumberQ[c];
GetDigit[c_] := 
  N[IntegerPart[c*10^Naccu]/10^Naccu, Naccu] /; NumberQ[c];
Default[GetDigit, 1] = 0;
GetDigit[p_Plus] := Map[GetDigit, p];
GetDigit[c_.*f_] := GetReal[c]*f /; NumberQ[c];

(************************************************************************)



(*Define the initial approximation of phi*)



(************************************************************************)



(*initial guess of the velocity potential*)

(*KV3=KV1-KV2;K3=Norm[KV3];(*reflected wavenumber*)*)
(*KV4=1*KV1+1*KV2;K4=Norm[KV4];*)


temp1 = Cosh[K1*(Z + epsilon1)]/Cosh[K1*epsilon1] // TrigToExp;



temp3 = Cosh[K3*(Z + epsilon1)]/Cosh[K3*epsilon1] // TrigToExp;

(*temp4=Cosh[K4*(Z+epsilon1)]/Cosh[K4*epsilon1]//TrigToExp;
temp5=Cosh[K5*(Z+epsilon1)]/Cosh[K5*epsilon1]//TrigToExp;*)


phi[0] = A[0]*Sin[x1]*temp1 + 
   B[0]*Sin[x1 - x2]*
    temp3 (*+CC[0]*Sin[5*x1+7*x2]*temp4+DD[0]*Sin[5*x1-12*x2]*temp5*);



Phi[0] = phi[0];
(*************************************)





(*initial guess of the wave elevation*)
eta[0] = 0;


Eta[0] = eta[0];

(*************************************)



(*the initially chosen value of the incident wave's angular frequency*)

sigma1[0] = 1;



Sigma1[0] = sigma1[0];

(*************************************)



chit[n_] := If[n == 1, 0, 1];


T[0] = 0; U[0] = 0; Vbar[0] = 0;


(*************************************)

Mu[Sin[m_.*x1 + n_.*x2]] := 
  Module[{temp}, 
   temp[1] = 
    Norm[m*KV1 + n*KV2]*
     Tanh[Norm[m*KV1 + n*KV2]*epsilon1]/Tanh[epsilon1]/m^2;
   temp[2] = 1*Sin[m*x1 + n*x2];
   If[m == 1 && n == -1, temp[2] = temp[1]*Sin[m*x1 + n*x2]];
   (*If[m\[Equal]5&&n\[Equal]7,temp[2]=temp[1]*Sin[m*x1+n*x2]];
   If[m\[Equal]5&&n\[Equal]-12,temp[2]=temp[1]*Sin[m*x1+n*x2]];*)
   temp[2]];

Mu[Sin[m_.*x1]] := 
  Module[{temp}, 
   If[m == 1, 
    temp[2] = 
     Norm[m*KV1]*Tanh[Norm[m*KV1]*epsilon1]/Tanh[epsilon1]/m^2*
      Sin[m*x1], 1*Sin[m*x1]]];

Mu[Sin[n_.*x2]] := Module[{temp}, temp[2] = 1*Sin[n*x2];
   temp[2]];

Mu[0] := 0;
Mu[p_Plus] := Map[Mu, p];
Mu[c_*f_] := c*Mu[f] /; FreeQ[c, x1] && FreeQ[c, x2];
(************************************************************************)

Mu2[Sin[m_.*x1 + n_.*x2]] := Module[{temp}, temp[1] = 1;
   temp[2] = Pi/3*Sin[m*x1 + n*x2];
   If[m == 1 && n == -1, temp[2] = temp[1]*Sin[m*x1 + n*x2]];
   temp[2]];

Mu2[Sin[m_.*x1]] := Module[{temp}, temp[1] = 1;
   temp[2] = Pi/3*Sin[m*x1];
   If[m == 1, temp[2] = temp[1]*Sin[m*x1]];
   temp[2]];

Mu2[Sin[n_.*x2]] := Module[{temp}, temp[2] = Pi/3*Sin[n*x2];
   temp[2]];

Mu2[0] := 0;
Mu2[p_Plus] := Map[Mu2, p];
Mu2[c_*f_] := c*Mu2[f] /; FreeQ[c, x1] && FreeQ[c, x2];
(************************************************************************)



(*Define L*)



(*This module defines the auxiliary linear operator*)



(************************************************************************)

L11[f_] := sigma1[0]^2*D[f, {x1, 2}] /. Z -> 0 // Mu;
L12[f_] := 
 1/Tanh[epsilon1]*D[f, {Z, 1}] /. Z -> 0 // Mu2;

L1[f_] := L11[f] + L12[f];
L2[f_] := (D[f, {Z, 1}]) /. Z -> -epsilon1;


(************************************************************************)



(*Define Linvb*)



(*In other words,find solution u of the following equation:*)



(*D[u,z]/.z\[Rule]-d=f*)



(************************************************************************)



Linvb[Sin[m_.*x1 + n_.*x2]] := Module[{temp},
  temp[0] = Sqrt[m^2 + n^2*K2^2 + 2*m*n*K2*Cos[alpha[1] - alpha[2]]] // check;
  If[temp[0] == 0,
    temp[1] = Limit[Sinh[x]/x, x -> 0], (* 使用极限值替代分母为0的情况 *)
    temp[1] = Sinh[temp[0]*Z]/Cosh[temp[0]*epsilon1]/temp[0] // TrigToExp
  ];
  temp[2] = Sin[m*x1 + n*x2]*temp[1] // Expand
];



Linvb[Sin[m_.*x1]] := 
  Module[{temp}, 
   temp[0] = 
    Sinh[Abs[m]*Z]/Cosh[Abs[m]*epsilon1]/(Abs[m]) // TrigToExp;
   temp[1] = Sin[m*x1]*(temp[0]) // Expand];




Linvb[Sin[n_.*x2]] := Module[{temp}, temp[0] = Sqrt[n^2*K2^2];
   temp[1] = 
    Sinh[temp[0]*Z]/Cosh[temp[0]*epsilon1]/temp[0] // TrigToExp;
   temp[2] = Sin[n*x2]*temp[1] // Expand];



Linvb[0] := 0;





(************************************************************************)



(*the property of the inverse operator of Lb*)



(*Linvb[f_+g_]:=Linvb[f]+Linvb[g]*)



(************************************************************************)



Linvb[p_Plus] := Map[Linvb, p];



Linvb[c_*f_] := 0 /; FreeQ[c, x1] && FreeQ[c, x2] && Abs[c] < 10^(-80);



Linvb[c_*f_] := c*Linvb[f] /; FreeQ[c, x1] && FreeQ[c, x2];





(************************************************************************)



(*the property of the inverse operator of check*)



(*check[f_+g_]:=check[f]+check[g]*)



(************************************************************************)





(*remove those small coefficients and small constants*)

check[p_Plus] := Map[check, p];



check[c_*f_] := 0 /; FreeQ[c, x1] && FreeQ[c, x2] && Abs[c] < 10^(-80);


check[c_] := 0 /; FreeQ[c, x1] && FreeQ[c, x2] && Abs[c] < 10^(-80);



check[f_] := f;



(*remove those terms larger than DropNum*)

Dp2[Sin[m_.*x1 + n_.*x2]] := 
  Module[{temp}, 
   If[Abs[m] > DropNum || Abs[n] > DropNum, temp[1] = 0, 
    temp[1] = Sin[m*x1 + n*x2]];
   temp[1]];



Dp2[Sin[m_.*x1]] := 
  Module[{temp}, 
   If[Abs[m] > DropNum, temp[1] = 0, temp[1] = Sin[m*x1]];
   temp[1]];



Dp2[Cos[m_.*x1 + n_.*x2]] := 
  Module[{temp}, 
   If[Abs[m] > DropNum || Abs[n] > DropNum, temp[1] = 0, 
    temp[1] = Cos[m*x1 + n*x2]];
   temp[1]];



Dp2[Cos[m_.*x1]] := 
  Module[{temp}, 
   If[Abs[m] > DropNum, temp[1] = 0, temp[1] = Cos[m*x1]];
   temp[1]];



Dp2[m_] := m;



Dp2[p_Plus] := Map[Dp2, p];

Dp2[c_*f_] := 0 /; FreeQ[c, x1] && FreeQ[c, x2] && Abs[c] < 10^(-80);

Dp2[c_*f_] := c*Dp2[f] /; FreeQ[c, x1] && FreeQ[c, x2];



(*************************************)




(*yuansu start*)

(************************************************************************)



(*Define mu[m,n]*)



(************************************************************************)



mu[1, n_] := eta[n];



mu[m_, n_] := 
  Module[{}, 
   If[! (NumberQ[muM[m, n]]), 
    muS[m, n] = 
     Sum[mu[m - 1, i]*eta[n - i], {i, m - 1, n - 1}] // TrigReduce // 
      Dp2;
    muM[m, n] = 1;];
   muS[m, n]];











(************************************************************************)



(*Define psi[n,m,i,j]*)



(************************************************************************)



psi[n_, m_, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[psiM[n, m, i, j]]), 
    psiS[n, m, i, j] = 
     D[phi[n], {Z, m}, {x1, i}, {x2, j}]/m! /. Z -> 0 // Expand // Dp2;
    psiM[n, m, i, j] = 1;];
   psiS[n, m, i, j]];





(************************************************************************)



(*Define psitilde[n,m,i,j]*)



(************************************************************************)



psitilde[n_, m_, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[psitildeM[n, m, i, j]]), 
    psitildeS[n, m, i, j] = 
     D[phi[n], {Z, m}, {x1, i}, {x2, j}]/m! /. Z -> -epsilon1 // 
      Expand;
    psitildeM[n, m, i, j] = 1;];
   psitildeS[n, m, i, j]];





(************************************************************************)



(*Define beta[n,m,i,j]*)



(************************************************************************)



beta[n_, 0, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[betaM[n, 0, i, j]]), 
    betaS[n, 0, i, j] = psi[n, 0, i, j] // Expand // Dp2;
    betaM[n, 0, i, j] = 1;];
   betaS[n, 0, i, j]];







beta[n_, m_, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[betaM[n, m, i, j]]), 
    betaS[n, m, i, j] = 
     Sum[psi[n, s, i, j]*mu[s, m]*epsilon2^s, {s, 1, m}] // 
       TrigReduce // Dp2;
    betaM[n, m, i, j] = 1;];
   betaS[n, m, i, j]];











(************************************************************************)



(*Define gamma[n,m,i,j]*)



(************************************************************************)



gamma[n_, 0, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[gammaM[n, 0, i, j]]), 
    gammaS[n, 0, i, j] = psi[n, 1, i, j] // Expand // Dp2;
    gammaM[n, 0, i, j] = 1;];
   gammaS[n, 0, i, j]];







gamma[n_, m_, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[gammaM[n, m, i, j]]), 
    gammaS[n, m, i, j] = 
     Sum[(s + 1)*psi[n, s + 1, i, j]*mu[s, m]*epsilon2^s, {s, 1, m}] //
        TrigReduce // Dp2;
    gammaM[n, m, i, j] = 1;];
   gammaS[n, m, i, j]];















(************************************************************************)



(*Define delta[n,m,i,j]*)



(************************************************************************)



delta[n_, 0, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[deltaM[n, 0, i, j]]), 
    deltaS[n, 0, i, j] = 2*psi[n, 2, i, j] // Expand // Dp2;
    deltaM[n, 0, i, j] = 1;];
   deltaS[n, 0, i, j]];







delta[n_, m_, i_, j_] := 
  Module[{}, 
   If[! (NumberQ[deltaM[n, m, i, j]]), 
    deltaS[n, m, i, j] = 
     Sum[(s + 1)*(s + 2)*psi[n, s + 2, i, j]*mu[s, m]*epsilon2^s, {s, 
         1, m}] // TrigReduce // Dp2;
    deltaM[n, m, i, j] = 1;];
   deltaS[n, m, i, j]];
(*yuansu end*)


(************************************************************************)

(*Define Getphibar with phibarz,phibarzz*)

(************************************************************************)
Getphibar[n_] := 
  Module[{m}, 
   phibar[n, 1, 0] = Sum[beta[n - m, m, 1, 0], {m, 0, n}] // Expand;

   (*Print["phibar[n,1,0] =" phibar[n,1,0]];*)

   phibar[n, 0, 1] = Sum[beta[n - m, m, 0, 1], {m, 0, n}] // Expand;

   (*Print["phibar[n,0,1] =" phibar[n,0,1]//N];*)

   phibar[n, 2, 0] = Sum[beta[n - m, m, 2, 0], {m, 0, n}] // Expand;

   (*Print["phibar[n,2,0] =" phibar[n,2,0]];*)

   phibar[n, 1, 1] = Sum[beta[n - m, m, 1, 1], {m, 0, n}] // Expand;

  (*Print["phibar[n,1,1] = " phibar[n,1,1]];*)

   phibar[n, 0, 2] = Sum[beta[n - m, m, 0, 2], {m, 0, n}] // Expand;

   (*Print["phibar[n,0,2] =" phibar[n,0,2]];*)

   phibarz[n, 0, 0] = Sum[gamma[n - m, m, 0, 0], {m, 0, n}] // Expand;

   (*Print["phibarz[n,0,0] ="phibarz[n,0,0]];*)

   phibarz[n, 1, 0] = Sum[gamma[n - m, m, 1, 0], {m, 0, n}] // Expand;

   (*Print["phibarz[n,1,0] = "phibarz[n,1,0]//N];*)

   phibarz[n, 0, 1] = Sum[gamma[n - m, m, 0, 1], {m, 0, n}] // Expand;

   (*Print["phibarz[n,0,1] ="phibarz[n,0,1]//N];*)

   phibarzz[n, 0, 0] = Sum[delta[n - m, m, 0, 0], {m, 0, n}] // Expand;

   (*Print["phibarzz[n,0,0] ="phibarzz[n,0,0]//N];*)];

(************************************************************************)

(*Define GAMMA[m,0],GAMMA[m,1],GAMMA[m,2],GAMMA[m,3]*)

(************************************************************************)



GetGAMMA[m_] := Module[{temp,n},

temp[1]  = Sum[phibar[n,1,0] * phibar[m-n,1,0] ,{n,0,m}]; 

temp[2]  = 2*K2*Cos[alpha[1]-alpha[2]]*Sum[phibar[n,1,0] * phibar[m-n,0,1] ,{n,0,m}];

temp[3]  = K2^2*Sum[phibar[n,0,1] * phibar[m-n,0,1] ,{n,0,m}]; 

temp[4]  = Sum[phibarz[n,0,0]* phibarz[m-n,0,0],{n,0,m}];

temp[5]  = (temp[1]+temp[2]+temp[3]+temp[4])/2//Expand;

(*Print["temp[5] = " temp[5]//N];*)

temp[6]  = temp[5];

GAMMA[m,0] = temp[5]//TrigReduce//Expand//GetDigit;



temp[1]  = Sum[phibar[n,1,0] * phibar[m-n,2,0] ,{n,0,m}](*//Expand*); 

temp[2]  = K2^2*Sum[phibar[n,0,1] * phibar[m-n,1,1] ,{n,0,m}](*//Expand*); 

temp[3]  = Sum[phibarz[n,0,0]* phibarz[m-n,1,0],{n,0,m}](*//Expand*);


temp[4]  = Sum[phibar[n,1,0] * phibar[m-n,1,1] ,{n,0,m}](*//Expand*); 

temp[5]  = Sum[phibar[n,0,1] * phibar[m-n,2,0],{n,0,m}](*//Expand*);

temp[6]  = K2*Cos[alpha[1]-alpha[2]]*(temp[4]+temp[5]);

temp[7]  = temp[1] + temp[2] + temp[3] + temp[6]//Expand;

(*Print["temp[77] = " temp[7]];*)

temp[8]  = temp[7];

GAMMA[m,1] = temp[8]//TrigReduce//Expand//GetDigit;



temp[1]  = Sum[phibar[n,1,0] * phibar[m-n,1,1] ,{n,0,m}](*//Expand*); 

temp[2]  = K2^2*Sum[phibar[n,0,1] * phibar[m-n,0,2] ,{n,0,m}](*//Expand*); 

temp[3]  = Sum[phibarz[n,0,0]* phibarz[m-n,0,1],{n,0,m}](*//Expand*);

temp[4]  = Sum[phibar[n,1,0] * phibar[m-n,0,2] ,{n,0,m}](*//Expand*); 

temp[5]  = Sum[phibar[n,0,1] * phibar[m-n,1,1] ,{n,0,m}](*//Expand*); 

temp[6]  = K2*Cos[alpha[1]-alpha[2]]*(temp[4]+temp[5]);

temp[7]  = temp[1] + temp[2] + temp[3] + temp[6]//Expand;

(*Print["temp[777] =" temp[7]];*)

temp[8]  = temp[7];

GAMMA[m,2] = temp[8]//TrigReduce//Expand//GetDigit;



temp[1]  = Sum[phibar[n,1,0] * phibarz[m-n,1,0] ,{n,0,m}](*//Expand*); 

temp[2]  = K2^2*Sum[phibar[n,0,1] * phibarz[m-n,0,1] ,{n,0,m}](*//Expand*); 

temp[3]  = Sum[phibarz[n,0,0]* phibarzz[m-n,0,0],{n,0,m}](*//Expand*);

temp[4]  = Sum[phibar[n,1,0] * phibarz[m-n,0,1] ,{n,0,m}](*//Expand*); 

temp[5]  = Sum[phibar[n,0,1] * phibarz[m-n,1,0] ,{n,0,m}](*//Expand*); 

temp[6]  = K2*Cos[alpha[1]-alpha[2]]*(temp[4]+temp[5]);

temp[7]  = temp[1] + temp[2] + temp[3] + temp[6]//Expand;

(*Print["temp[7777] =" temp[7]];*)

temp[8]  = temp[7];

GAMMA[m,3] = temp[8]//TrigReduce//Expand//GetDigit;

];

(************************************************************************)



(*Define Lambda[m]*)



(************************************************************************)

GetLambda[m_] := Module[{temp,n},

temp[1]   = Sum[phibar[n,1,0]  * GAMMA[m-n,1],{n,0,m}]//Expand; 

temp[2]   = K2^2*Sum[phibar[n,0,1]  * GAMMA[m-n,2],{n,0,m}]//Expand; 

temp[3]   = Sum[phibarz[n,0,0] * GAMMA[m-n,3],{n,0,m}]//Expand;

temp[4]   = Sum[phibar[n,1,0]  * GAMMA[m-n,2],{n,0,m}](*//Expand*); 

temp[5]   = Sum[phibar[n,0,1]  * GAMMA[m-n,1],{n,0,m}](*//Expand*); 

temp[6]   = K2*Cos[alpha[1]-alpha[2]]*(temp[4]+temp[5])//Expand;

temp[7]   = temp[1] + temp[2] + temp[3] + temp[6]//Expand;

(*Print["temp[7] =" temp[7]//N];*)

temp[8]   = temp[7]//Expand;

Lambda[m] = temp[8]//TrigReduce//Expand//GetDigit;

];


(************************************************************************)



(*Define GetDelta[m]*)



(************************************************************************)

GetDelta[m_] := Module[{temp,n,i,j},

temp[1]  = Sum[Sum[sigma1[j]*sigma1[i-j],{j,0,i}]*phibar[m-i,2,0],{i,0,m}];

temp[2]  = phibarz[m,0,0]/Tanh[epsilon1]//Expand;

temp[3]  = -2*epsilon2*Sum[sigma1[i]*GAMMA[m-i,1],{i,0,m}];

temp[4]  = epsilon2^2*Lambda[m]//Expand;

temp[5]  = temp[1] + temp[2] + temp[3] + temp[4];

(*Print["temp[5] =" temp[5]//N];*)

Delta[m] = temp[5]//TrigReduce//Expand//GetDigit;

];


(************************************************************************)



(*Define Geteta*)



(************************************************************************)


Geteta[m_] := Module[{temp, n,i},

   temp[1] = Sum[sigma1[i]*phibar[m-1-i,1,0],{i,0,m-1}];
   
   DeltaEta[m - 1] = eta[m - 1] - Tanh[epsilon1]*(temp[1]) + epsilon2*Tanh[epsilon1]*GAMMA[m - 1, 0]// Expand; 

   temp[3] = eta[m - 1] + hbar*DeltaEta[m - 1] // Expand; 

   (*Print["temp[3] =" temp[3]//N];*)
   
   eta[m]  = temp[3]//TrigReduce//Expand//check//Dp2//GetDigit;
   
   ];


(************************************************************************)



(*eta[m] is included in U[m]*)



(************************************************************************)



GetU[n_] :=  Module[{temp, m}, 

temp[1] =  sigma1[0]^2*Sum[beta[n - m, m, 2, 0], {m, 1, n}]//Expand //Mu;
    
(*Print["temp[1] =" temp[1]];*)

temp[4] =  Sum[gamma[n - m, m, 0, 0], {m, 1, n}]/Tanh[epsilon1]//Expand //Mu2;(*add Mu,Mu2,*)

(*Print["temp[4] =" temp[4]];*)

temp[5] = temp[1] + temp[4]//Expand;

(*Print["temp[5] =" temp[5]//N];*)

temp[6] = temp[5];

U[n] = temp[6] // TrigReduce // Expand // GetDigit;

];




GetT[n_] := Module[{temp,i,j},

temp[1] = Sum[Sum[sigma1[j]*sigma1[n-i-j],{j,0,n-i}]*phibar[i,2,0],{i,0,n-1}]//Expand//Mu;

temp[5] = temp[1]//Expand;

(*Print["temp[55] =" temp[5]//N];*)

temp[6] = temp[5];

T[n] = temp[6]//TrigReduce//Expand//GetDigit;

];

(************************************************************************)



(*Define GetS*)



(************************************************************************)



GetS[n_] := Module[{temp}, 
   
temp[1] = beta[n, 0, 2, 0]*sigma1[0]^2 // Expand // Mu;(*2022.6.5 add Mu,Mu2,Otherwise, after mu2 is added to the above auxiliary linear operator, the error data of output errphi2 will not increase after order 6, and the addition of dropnum is invalid*)
   
(*Print["temp[1] =" temp[1]];*)

temp[4] = gamma[n, 0, 0, 0]/Tanh[epsilon1] // Expand // Mu2;
  
(*Print["temp[4] =" temp[4]]; *)

temp[5] = temp[1] + temp[4] // Expand;
   
(*Print["temp[5] =" temp[5]//N];*)

temp[6] = temp[5] + T[n] + U[n] // Expand;
   

S[n] = temp[6] // TrigReduce // Expand // GetDigit;

];





(************************************************************************)



(*Define GetRHS*)



(*RHS[m] is related with eta[m],so eta[m] is before RHS*)



(************************************************************************)




GetRHS[m_] := 
  Module[{temp}, 
   temp[1] = hbar*Delta[m - 1] + S[m - 1] - U[m] - T[m] // Expand;

   (*Print["temp[1] =" temp[1]//N];*)

   RHS[m] = 
    temp[1] // check // TrigReduce // Dp2 // Expand // GetDigit];




(************************************************************************)



(*the bottom boundary*)



(*Define GetDeltaB*)



(************************************************************************)



GetDeltaB[n_] := 
  Module[{temp, m}, temp[1] = psitilde[n, 1, 0, 0] // Expand;
   temp[2] = -epsilon3*K2*zetax2*Cos[alpha[1] - alpha[2]]*
      psitilde[n, 0, 1, 0] // Expand;
   temp[3] = -epsilon3*K2^2*zetax2*psitilde[n, 0, 0, 1] // Expand;
   temp[4] = temp[1] + temp[2] + temp[3] // Expand;

(*Print["temp[4] =" temp[4]//N];*)

   temp[5] = Map[TrigReduce, temp[4]];
   temp[1] = 
    Sum[(epsilon3^m)*(zeta^m)*(m + 1)*
       psitilde[n - m, m + 1, 0, 0], {m, 1, n}] // Expand;
   temp[2] = -Sum[(epsilon3^m)*(zeta^m)*epsilon3*K2*zetax2*
        Cos[alpha[1] - alpha[2]]*psitilde[n - m, m, 1, 0], {m, 1, 
        n}] // Expand;
   temp[3] = -Sum[(epsilon3^m)*(zeta^m)*epsilon3*K2^2*zetax2*
        psitilde[n - m, m, 0, 1], {m, 1, n}] // Expand;
   temp[4] = temp[1] + temp[2] + temp[3] // Expand;

(*Print["temp[44] = ", temp[4]//N];*)

   temp[6] = Map[TrigReduce, temp[4]];
   DeltaB[n] = temp[5] + temp[6] // check;];



(************************************************************************)



(*Define GetVbar*)



(************************************************************************)

GetVbar[m_] :=  Module[{temp},
 
temp[1] =  Sum[(i + 1)*epsilon3^i*zeta^i*psitilde[m - i, i + 1, 0, 0], {i, 1,
        m - 1}] // Expand;

(*Print["temp[1] = ", temp[1]];*)

temp[2] = Map[TrigReduce, temp[1]];

(*Print["temp[2] = ", temp[2]//N];*)

Vbar[m] = temp[2] // check;

];

(************************************************************************)



(*Define GetV*)



(************************************************************************)



GetV[m_] := Module[{temp}, 

temp[1] = psitilde[m, 1, 0, 0] + Vbar[m] // Expand;

(*Print["temp[1] = ", temp[1]//N];*)

temp[2] = Map[TrigReduce, temp[1]];

V[m] = temp[2] // check;

];


(************************************************************************)



(*Define GetRHSB*)



(************************************************************************)


GetRHSB[m_] :=  Module[{temp}, 

temp[1] = hbar*DeltaB[m - 1] + chit[m]*V[m - 1] - Vbar[m] // Expand;

(*Print["temp[1] = ", temp[1]];*)

temp[2] = Map[TrigReduce, temp[1]];

(*Print["temp[2] = ", temp[2]//N];*)

temp[3] = temp[2] // Expand;

RHSB[m] = temp[3] // check;

];


(************************************************************************)


(*Define common solution of L2[f]=0*)



(************************************************************************)



GetCommon1[m_] := Module[{temp, i, j, s}, s = 0;
   For[i = 1, i <= DropNum, i = i + 1, 
    For[j = -DropNum, j <= DropNum, j = j + 1,

(*Print["i=",i,",j=",j];*)

temp[0] =Sqrt[i^2 + j^2*K2^2 + 2*i*j*K2*Cos[alpha[1] - alpha[2]]] //check;

(*Print["temp[0] = ", temp[0]];*)

temp[1] =Cosh[temp[0]*(Z + epsilon1)]/Cosh[temp[0]*epsilon1] //TrigToExp;

temp[2] = u[m, i, j]*Sin[i*x1 + j*x2]*temp[1](*//check*);

      s = s + temp[2];];];

   bcommon1[m] = s // Expand;

(*Print["bcommon1[m] = ", bcommon1[m]//N];*)

];



GetCommon2[m_] := Module[{temp, j, s}, s = 0;
   For[j = 1, j <= DropNum, j = j + 1, 

temp[0] = Sqrt[j^2*K2^2];

(*Print["temp[0] = ", temp[0]//N];*)

    temp[1] = 
     Cosh[temp[0]*(Z + epsilon1)]/Cosh[temp[0]*epsilon1] // TrigToExp;

(*Print["temp[1] = ", temp[1]//N];*)

    temp[2] = u[m, 0, j]*Sin[j*x2]*temp[1](*//check*);

(*Print["temp[2] = ", temp[2]//N];*)

    s = s + temp[2];];

   bcommon2[m] = s // Expand;];

balance1[m_] := 
  Module[{temp, i, j}, 
   For[i = 1, i <= DropNum, i = i + 1, 
     For[j = -DropNum, j <= DropNum, j = j + 1, 
       eq[i, j] = Coefficient[surface, Sin[i*x1 + j*x2]](*//check*);
       (*Print["eq[",i,",",j,"]=",eq[i,j]//N]*)
];];];

balance2[m_] := 
  Module[{temp, j}, 
   For[j = 1, j <= DropNum, j = j + 1, 
     eq[0, j] = Coefficient[surface, Sin[j*x2]](*//check*);
     (*Print["eq[0,",j,"]=",eq[0,j]//N]*)
];];



getu1[m_] := Module[{temp, i, j}, eq[1, 0] = 0;
   u[m, 1, 0] = 0;
   If[Nlambda == 3, eq[1, -1] = 0; u[m, 1, -1] = 0];
   For[i = 1, i <= DropNum, i = i + 1, 
    For[j = -DropNum, j <= DropNum, j = j + 1, 
      temp[0] = eq[i, j] // check;
      If[NumberQ[temp[0]], u[m, i, j] = 0, 
       temp[1] = Solve[eq[i, j] == 0, u[m, i, j]];
       u[m, i, j] = temp[1][[1]][[1, 2]];
       (*Print["u[",m,",",i,",",j,"]=",u[m,i,j]//N]*)
];
];];];



getu2[m_] := 
  Module[{temp, i, j}, 
   For[j = 1, j <= DropNum, j = j + 1, 
     temp[1] = Solve[eq[0, j] == 0, u[m, 0, j]];
     u[m, 0, j] = temp[1][[1]][[1, 2]];
     (*Print["u[",m,",",0,",",j,"]=",u[m,0,j]//N]*)
];];


checkhoeqs[m_] := 
  Module[{temp}, 
   temp[1] = L1[phi[m]] - RHS[m] // Together // Expand // check;
  (*Print["temp[1]=",temp[1]//N];*)
   temp[2] = L2[phi[m]] - RHSB[m] // Together // Expand // check;
  (*Print["temp[2]=",temp[2]//N];*)
   temp[3] = 
    eta[m] - (eta[m - 1] + hbar*DeltaEta[m - 1]) // Together // 
      Expand // check;
   (*Print["temp[3]=",temp[3]//N];*)
   If[temp[1] == 0 && temp[2] == 0 && temp[3] == 0, 
    If[m == 1, Print["1st-order eqs are satisfied !"]];
    If[m == 2, Print["2nd-order eqs are satisfied !"]];
    If[m == 3, Print["3rd-order eqs are satisfied !"]];
    If[m > 3, Print[m, "th-order eqs are satisfied !"]];];];

GetMIn1[begin_, end_] := Module[{i}, filename1 = "hbar_ErrPhi2.dat";
   OpenAppend[filename1];
   PutAppend["data of ErrPhi2", filename1];
   L0 = Join[{m}, Table[i, {i, begin - 1, end - 1, 1}]];
   PutAppend[L0, filename1];
   Close[filename1];];

GetMIn2[begin_, end_] := Module[{i}, filename2 = "hbar_ErrZ2.dat";
   OpenAppend[filename2];
   PutAppend["data of ErrZ2", filename2];
   L0 = Join[{m}, Table[i, {i, begin - 1, end - 1, 1}]];
   PutAppend[L0, filename2];
   Close[filename2];];

GetMIn3[begin_, end_] := Module[{i}, filename3 = "hbar_ErrB2.dat";
   OpenAppend[filename3];
   PutAppend["data of ErrB2", filename3];
   L0 = Join[{m}, Table[i, {i, begin - 1, end - 1, 1}]];
   PutAppend[L0, filename3];
   Close[filename3];];

HamSigmaUnknow[begin_, end_] := 
  Block[{temp, m, i}, 
   For[m = begin, m <= end, m = m + 1, Print["m  = ", m];
    Getphibar[m - 1];
    GetGAMMA[m - 1];
    GetLambda[m - 1];
    GetDelta[m - 1];
    GetT[m];
    Geteta[m];
    Eta[m] = Eta[m - 1] + eta[m] // Expand;
    GetU[m];
    GetS[m - 1];
    GetRHS[m];
    GetDeltaB[m - 1];
    GetV[m - 1];
    GetVbar[m];
    GetRHSB[m];
    bspecial[m] = Linvb[RHSB[m]] // Expand;
    GetCommon1[m]; GetCommon2[m];
    phib[m] = bspecial[m] + bcommon1[m] + bcommon2[m] // Expand;
    surfaceleft = L1[phib[m]] // Expand;
    surface = surfaceleft - RHS[m] // Expand;
    balance1[m]; balance2[m];
    If[m == 1, temp[1] = eq[1, 0] // check // GetDigit;
     temp[2] = eq[1, -1] // check // GetDigit;
     (*temp[3]=eq[5,7]//check//GetDigit;
     temp[4]=eq[5,-12]//check//GetDigit;*)
     temp[5] = Coefficient[eta[1], Cos[x1]] - A0 // check // GetDigit;
     temp[0] = 
      NSolve[{temp[1] == 0, temp[2] == 0,(*temp[3]\[Equal]0,temp[
        4]\[Equal]0,*)temp[5] == 0}, {A[0], B[0](*,CC[0],DD[0]*), 
        sigma1[1]}, WorkingPrecision -> Naccu - 10];
     For[i = 1, i <= Length[temp[0]], i = i + 1, 
      A[0] = A[0] /. temp[0][[i]];
      B[0] = B[0] /. temp[0][[i]];
      (*CC[0]=CC[0]/.temp[0][[i]];
      DD[0]=DD[0]/.temp[0][[i]];*)
      sigma1[1] = sigma1[1] /. temp[0][[i]];
      If[Im[A[0]] == 0 && Im[B[0]] == 0 (*&&Im[CC[0]]\[Equal]0&&Im[DD[
        0]]\[Equal]0*)&& Im[sigma1[1]] == 0, 
       Print[" i  =  ", i, ", A[", 0, "]=", A[0] // N, ", B[", 0, 
         "]=", B[0] // N(*,", CC[",0,"]=",CC[0]//N,", DD[",0,"]=",DD[
         0]//N*), ", sigma1[", 1, "] = ", 
         sigma1[1] // N];];];(*For ends*)Print["NumS = ?"];

     NumS =3(*Input[](*input方便求解HamSU使用*)*) ;

     Print[" NumS  =  ", NumS];
     A[0] = A[0] /. temp[0][[NumS]];
     B[0] = B[0] /. temp[0][[NumS]];
     (*CC[0]=CC[0]/.temp[0][[NumS]];
     DD[0]=DD[0]/.temp[0][[NumS]];*)
     sigma1[1] = sigma1[1] /. temp[0][[NumS]];
     Print["A[", 0, "]=", A[0] // N, ", B[", 0, "]=", B[0] // N(*,
      ", CC[",0,"]=",CC[0]//N,", DD[",0,"]=",DD[0]//N*), ", sigma1[", 
      1, "] = ", sigma1[1] // N];];(*If ends*)
    If[m > 1, temp[1] = eq[1, 0] // check // GetDigit;
     temp[2] = eq[1, -1] // check // GetDigit;
     (*temp[3]=eq[5,7]//check//GetDigit;
     temp[4]=eq[5,-12]//check//GetDigit;*)
     temp[5] = Coefficient[eta[m], Cos[x1]] // check // GetDigit;
     temp[0] = 
      NSolve[{temp[1] == 0, temp[2] == 0(*,temp[3]\[Equal]0,temp[
        4]\[Equal]0*), temp[5] == 0}, {A[m - 1], B[m - 1](*,CC[m-1],
        DD[m-1]*), sigma1[m]}, WorkingPrecision -> Naccu - 10];
     A[m - 1] = A[m - 1] /. temp[0][[1]];
     B[m - 1] = B[m - 1] /. temp[0][[1]];
     (*CC[m-1]=CC[m-1]/.temp[0][[1]];
     DD[m-1]=DD[m-1]/.temp[0][[1]];*)
     sigma1[m] = sigma1[m] /. temp[0][[1]];];(*If ends*)
    Sigma1[m] = Sigma1[m - 1] + sigma1[m];
    getu1[m]; getu2[m];
    phi[m] = 
     phib[m] + A[m]*Sin[x1]*temp1 + B[m]*Sin[x1 - x2]*temp3(*+CC[m]*
      Sin[5*x1+7*x2]*temp4+DD[m]*Sin[5*x1-12*x2]*temp5*)// Expand;
    Phi[m] = Phi[m - 1] + phi[m] // Expand;
    checkhoeqs[m];

    (*error starts*)(*using the RHS*)
    SumDelta[m - 1] = Sum[Delta[i], {i, 0, m - 1}];
    SumDeltaEta[m - 1] = Sum[DeltaEta[i], {i, 0, m - 1}];
    SumDeltaB[m - 1] = Sum[DeltaB[i], {i, 0, m - 1}];
    GetErrPhi2[m - 1];
    GetErrZ2[m - 1];
    GetErrB2[m - 1];
    Print["ErrPhi2[", m - 1, "]=", ErrPhi2[m - 1] // N];
    Print["ErrZ2[", m - 1, "]=", ErrZ2[m - 1] // N];
    Print["ErrB2[", m - 1, "]=", ErrB2[m - 1] // N];
    (*substitute into eqs*)(*GetErrPhi[m-1];
    GetErrPhiLS[m-1];
    GetErrZ[m-1];
    GetErrB[m-1];
    Print["ErrPhi[",m-1,"]=",ErrPhi[m-1]//N];
    Print["ErrPhiLS[",m-1,"]=",ErrPhiLS[m-1]//N];
    Print["ErrZ[",m-1,"]=",ErrZ[m-1]//N];
    Print["ErrB[",m-1,"]=",ErrB[m-1]//N];*)(*GetErrPhiHbar[m-1];
    GetErrZHbar[m-1];GetErrBHbar[m-1];*)(*error ends*)];

   (*GetMIn1[begin,end];GetMIn2[begin,end];GetMIn3[begin,
   end];*)(*add this if not include in HamSUHbar[]*)
   L1 = Join[{FortranForm[N[hbar, 6]]}, 
     Table[FortranForm[N[ErrPhi2[i], 8]], {i, begin - 1, end - 1, 1}]];
   L2 = Join[{FortranForm[N[hbar, 6]]}, 
     Table[FortranForm[N[ErrZ2[i], 8]], {i, begin - 1, end - 1, 1}]];
   L3 = Join[{FortranForm[N[hbar, 6]]}, 
     Table[FortranForm[N[ErrB2[i], 8]], {i, begin - 1, end - 1, 1}]];
   PutAppend[L1, filename1];
   PutAppend[L2, filename2];
   PutAppend[L3, filename3];];


(*to get hear curve*)

HamSUHbar[begin_, end_, hmin_, hmax_, Nh_] := 
  Block[{temp, m, i, j}, dh = (hmax - hmin)/Nh;
   GetMIn1[begin, end]; GetMIn2[begin, end]; GetMIn3[begin, end];
   For[j = 0, j <= Nh, j++, Print["------------------"];
    Print["j=", j];
    h[j] = hmin + j*dh;
    hbar = N[h[j], Naccu];
    Print["hbar=", hbar // N];
    << "C:\\Users\\13975\\Desktop\\3.txt";
    HamSigmaUnknow[begin, end];
    Clear[hbar, mu, muS, muM, psi, psitilde, psiS, psiM, psitildeS, 
     psitildeM, beta, betaS, betaM, gamma, gammaS, gammaM, delta, 
     deltaS, deltaM, A, B, eta, Eta, phi, Phi, sigma1, Sigma1, phibar,
      phibarz, phibarzz, GAMMA, Lambda, Delta, Vbar, T, S, U, V, 
     DeltaEta, DeltaB, RHS, RHSB, u, bcommon1, bcommon2, bspecial, eq,
      phib, SumDelta, SumDeltaEta, SumDeltaB, L1, L2, L3];];];

(*give hear,to get phi and eta*)
HamSU[begin_, end_, hbarI_] := Block[{}, hbar = N[hbarI, Naccu];
   GetMIn1[begin, end]; GetMIn2[begin, end]; GetMIn3[begin, end];
   <<"C:\\Users\\13975\\Desktop\\3.txt";
   HamSigmaUnknow[begin, end];];




(*end=10;
Print["1. Pade sigma/omega"];
For[ii=1,ii\[LessEqual]end/2,ii++,Print["m=n=",ii,", \
hp-sigma1/omega1=",hpw[Sigma1,ii,ii]//N];];
Print["------------------"];
For[ii=1,ii\[LessEqual]end/2,ii++,Print["m=n=",ii,", \
hp-sigma2/omega2=",hpw[Sigma2,ii,ii]*Sqrt[1/k2*Tanh[epsilon1]/Tanh[k2*\
epsilon1]]//N];];
Print["------------------"];
For[ii=1,ii\[LessEqual]end/2,ii++,Print["m=n=",ii,", \
hp-sigma3/omega3=",(2*hpw[Sigma1,ii,ii]-hpw[Sigma2,ii,ii])/(2-Sqrt[k2*\
Tanh[k2*epsilon1]/Tanh[epsilon1]])//N];];
Print["**************************"];
Print["2. natural sigma/omega"];
sw1=Sigma1[end];
sw2=Sigma2[end]*Sqrt[1/k2*Tanh[epsilon1]/Tanh[k2*epsilon1]];
sw3=(2*Sigma1[end]-Sigma2[end])/(2-Sqrt[k2*Tanh[k2*epsilon1]/Tanh[\
epsilon1]]);
Print["sigma1/omega1=",sw1//N];
Print["sigma2/omega2=",sw2//N];
Print["sigma3/omega3=",sw3//N];
GetHPA[4,4,4];
Print["----------------"];
Print["Both a and k are dimensional"];
Print["1. Pade ak:"];
ak12=k1*a[1,0]*epsilon2;
ak22=k2*a[0,1]*epsilon2;
ak32=k3*a[2,-1]*epsilon2;
Print["ak12=",ak12//N];
Print["ak22=",ak22//N];
Print["ak32=",ak32//N];
Print["2. natural ak:"];
ak11=k1*Coefficient[Eta[end],Cos[x1]]*epsilon2;
ak21=k2*Coefficient[Eta[end],Cos[x2]]*epsilon2;
ak31=k3*Coefficient[Eta[end],Cos[2 x1-x2]]*epsilon2;
Print["ak11=",ak11//N];
Print["ak21=",ak21//N];
Print["ak31=",ak31//N];
Print["----------------"];
Print["Pade energy distribution:"];
GetDisHP[4]*)

(*errphi starts*)
GetErrPhi[m_] := 
  Module[{temp, error, dx, dy, M, err, i, j, X1, X2, ZZ}, 
   Phix1 = D[Phi[m], x1];
   Phix2 = D[Phi[m], x2];
   Phiz = D[Phi[m], Z];
   Etax1 = D[Eta[m], x1];
   Etax2 = D[Eta[m], x2];
   M = 10;
   dx = N[Pi/M, 100];
   dy = N[Pi/M, 100];
   err = 0;
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     ZZ = epsilon2*Eta[m] /. {x1 -> X1, x2 -> X2} // Expand;
     Phix1ij = Phix1 /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Phix2ij = Phix2 /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Phizij = Phiz /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Etax1ij = Etax1 /. {x1 -> X1, x2 -> X2};
     Etax2ij = Etax2 /. {x1 -> X1, x2 -> X2};
     temp[1] = Etax1ij;
     temp[2] = Phizij;
     temp[4] = epsilon2*Phix1ij*Etax1ij;
     temp[5] = epsilon2*K2^2*Phix2ij*Etax2ij;
     temp[6] = 
      epsilon2*K2*
       Cos[alpha[1] - alpha[2]]*(Phix1ij*Etax2ij + Phix2ij*Etax1ij);
     temp[10] = temp[4] + temp[5] + temp[6] // Expand;
     errorPhi[m] = -Sigma1[m]*temp[1] + temp[10] - temp[2] // Expand;
     temp[0] = errorPhi[m];
     temp[1] = temp[0] // Expand;
     err = err + temp[1]*temp[1];];];
   ErrPhi[m] = err/(M + 1)/(M + 1) // Together;];

GetErrPhiLS[m_] := 
  Module[{temp, error, dx, dy, M, err, i, j, X1, X2, ZZ, F, Fx1, Fx2, 
    Fz, Phix1, Phix2, Phiz, Phix1x1, Phix1x2, Phix2x2, Fx1ij, Fx2ij, 
    Fzij, Phix1ij, Phix2ij, Phizij, Phix1x1ij, Phix1x2ij, Phix2x2ij, 
    Phix1zij, Phix2zij, Phizzij, DX1, DX2, DZ}, M = 20;
   dx = N[Pi/M, 50];
   dy = N[Pi/M, 50];
   err = 0;
   DX1 = N[10^(-10), Naccu];
   DX2 = N[10^(-10), Naccu];
   DZ = N[10^(-10), Naccu];
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     ZZ = 
      epsilon2*Eta[m] /. {x1 -> X1, x2 -> X2} // Expand // GetDigit;
     temp[1] = 
      Phi[m] /. {x1 -> X1 + DX1, x2 -> X2, Z -> ZZ} // GetDigit;
     temp[2] = Phi[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ} // GetDigit;
     Phix1ij = (temp[1] - temp[2])/DX1 // Expand // GetDigit;
     temp[3] = 
      Phi[m] /. {x1 -> X1 + 2*DX1, x2 -> X2, Z -> ZZ} // GetDigit;
     Phix1x1ij = (temp[3] - 2*temp[1] + temp[2])/DX1/DX1 // GetDigit;
     temp[4] = 
      Phi[m] /. {x1 -> X1 + DX1, x2 -> X2 + DX2, Z -> ZZ} // GetDigit;
     temp[5] = 
      Phi[m] /. {x1 -> X1, x2 -> X2 + DX2, Z -> ZZ} // GetDigit;
     Phix1x2ij = ((temp[4] - temp[5])/DX1 - Phix1ij)/DX2 // Expand // 
       GetDigit;
     Phix2ij = (temp[5] - temp[2])/DX2 // GetDigit;
     temp[6] = 
      Phi[m] /. {x1 -> X1, x2 -> X2 + 2*DX2, Z -> ZZ} // GetDigit;
     Phix2x2ij = (temp[6] - 2*temp[5] + temp[2])/DX2/DX2 // GetDigit;
     temp[7] = 
      Phi[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ + DZ} // GetDigit;
     Phizij = (temp[7] - temp[2])/DZ // GetDigit;
     temp[8] = 
      Phi[m] /. {x1 -> X1 + DX1, x2 -> X2, Z -> ZZ + DZ} // GetDigit;
     temp[9] = 
      Phi[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ + DZ} // GetDigit;
     Phix1zij = ((temp[8] - temp[9])/DX1 - Phix1ij)/DZ // Expand // 
       GetDigit;
     temp[10] = 
      Phi[m] /. {x1 -> X1, x2 -> X2 + DX2, Z -> ZZ + DZ} // GetDigit;
     temp[11] = 
      Phi[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ + DZ} // GetDigit;
     Phix2zij = ((temp[10] - temp[11])/DX2 - Phix2ij)/DZ // Expand // 
       GetDigit;
     temp[12] = 
      Phi[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ + 2*DZ} // GetDigit;
     Phizzij = (temp[12] - 2*temp[7] + temp[2])/DZ/DZ // GetDigit;
     Fx1ij = 
      Phix1ij*Phix1x1ij + 
        K2*Cos[alpha[1] - alpha[2]]*(Phix1x1ij*Phix2ij + 
           Phix1ij*Phix1x2ij) + K2^2*Phix2ij*Phix1x2ij + 
        Phizij*Phix1zij (*//Expand*)// GetDigit;
     Fx2ij = 
      Phix1ij*Phix1x2ij + 
        K2*Cos[alpha[1] - alpha[2]]*(Phix1x2ij*Phix2ij + 
           Phix1ij*Phix2x2ij) + K2^2*Phix2ij*Phix2x2ij + 
        Phizij*Phix2zij (*//Expand*)// GetDigit;
     Fzij = 
      Phix1ij*Phix1zij + 
        K2*Cos[alpha[1] - alpha[2]]*(Phix1zij*Phix2ij + 
           Phix1ij*Phix2zij) + K2^2*Phix2ij*Phix2zij + 
        Phizij*Phizzij (*//Expand*)// GetDigit;
     temp[1] = Sigma1[m]^2*Phix1x1ij;
     temp[4] = Phizij/Tanh[epsilon1];
     temp[5] = -2*epsilon2*Sigma1[m]*Fx1ij;
     temp[6] = Phix1ij*Fx1ij;
     temp[7] = 
      K2*Cos[alpha[1] - alpha[2]]*(Phix1ij*Fx2ij + Phix2ij*Fx1ij);
     temp[8] = K2^2*Phix2ij*Fx2ij;
     temp[9] = Phizij*Fzij;
     temp[10] = epsilon2^2*(temp[6] + temp[7] + temp[8] + temp[9]) (*//
     Expand*);
     errorPhiLS[m] = temp[1] + temp[4] + temp[5] + temp[10] (*//
     Expand*);
     temp[0] = errorPhiLS[m];
     temp[1] = temp[0] (*//Expand*);
     err = err + temp[1]*temp[1];];];
   ErrPhiLS[m] = err/(M + 1)/(M + 1) // Together;];


GetErrPhi2[m_] := 
  Module[{temp, error, dx, dy, M, err, i, j, X1, X2, ZZ, F, Fx1, Fx2, 
    Fz}, M = 10;
   dx = N[Pi/M, 100];
   dy = N[Pi/M, 100];
   err = 0;
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     ZZ = Eta[m] /. {x1 -> X1, x2 -> X2} // Expand;
     temp[0] = SumDelta[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     temp[1] = temp[0] // Expand;
     err = err + temp[1]*temp[1];];];
   ErrPhi2[m] = err/(M + 1)/(M + 1) // Together;];
(*errphi ends*)


(*errz starts*)
GetErrZ[m_] := 
  Module[{temp, Etaij, errorZ, dx, dy, M, err, i, j, X1, X2, ZZ}, 
   Phix1 = D[Phi[m], x1];
   Phix2 = D[Phi[m], x2];
   Phiz = D[Phi[m], Z];
   M = 10;
   dx = N[Pi/M, 100];
   dy = N[Pi/M, 100];
   err = 0;
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     ZZ = epsilon2*Eta[m] /. {x1 -> X1, x2 -> X2};
     Etaij = Eta[m] /. {x1 -> X1, x2 -> X2};
     Phix1ij = Phix1 /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Phix2ij = Phix2 /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Phizij = Phiz /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     temp[2] = Phix1ij^2;
     temp[3] = 2*K2*Cos[alpha[1] - alpha[2]]*Phix1ij*Phix2ij;
     temp[4] = K2^2*Phix2ij^2;
     temp[5] = Phizij^2;
     temp[6] = (temp[2] + temp[3] + temp[4] + temp[5])/2;
     errorZ[m] = 
      Etaij - Sigma1[m]*Tanh[epsilon1]*Phix1ij + 
       epsilon2*Tanh[epsilon1]*temp[6];
     temp[0] = errorZ[m];
     err = err + temp[0]*temp[0];];];
   ErrZ[m] = err/(M + 1)/(M + 1) // Together;];


GetErrZ2[m_] := 
  Module[{temp, error, dx, dy, M, err, i, j, X1, X2, ZZ, F, Fx1, Fx2, 
    Fz}, M = 10;
   dx = N[Pi/M, 100];
   dy = N[Pi/M, 100];
   err = 0;
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     ZZ = Eta[m] /. {x1 -> X1, x2 -> X2};
     temp[0] = SumDeltaEta[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     temp[1] = temp[0] // Expand;
     err = err + temp[1]*temp[1];];];
   ErrZ2[m] = err/(M + 1)/(M + 1) // Together;];

(*errz ends*)


(*errb starts*)
GetErrB[m_] := 
  Module[{temp, error, dx, dy, M, err, i, j, X1, X2, ZZ}, 
   Phiz = D[Phi[m], Z];
   Phix1 = D[Phi[m], x1];
   Phix2 = D[Phi[m], x2];
   M = 10;
   dx = N[Pi/M, 100];
   dy = N[Pi/M, 100];
   err = 0;
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     ZZ = epsilon3*zeta - epsilon1 /. {x2 -> X2} // Expand;
     Phizij = Phiz /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Phix1ij = Phix1 /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     Phix2ij = Phix2 /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     zetax2ij = zetax2 /. {x2 -> X2};
     temp[1] = Phizij;
     temp[2] = Cos[alpha[1] - alpha[2]]*Phix1ij;
     temp[3] = K2*Phix2ij;
     temp[4] = epsilon3*K2*zetax2ij*(temp[2] + temp[3]);
     errorB[m] = temp[1] - temp[4];
     temp[0] = errorB[m] /. {x1 -> X1, x2 -> X2, Z -> ZZ};
     err = err + temp[0]*temp[0];];];
   ErrB[m] = err/(M + 1)/(M + 1) // Together;];





GetErrB2[m_] := 
  Module[{temp, error, dx, dy, M, err, i, j, X1, X2, ZZ}, M = 10;
   dx = N[Pi/M, 100];
   dy = N[Pi/M, 100];
   err = 0;
   For[i = 0, i <= M, i = i + 1, X1 = dx*i;
    For[j = 0, j <= M, j = j + 1, X2 = dy*j;
     temp[0] = SumDeltaB[m] /. {x1 -> X1, x2 -> X2};
     temp[1] = temp[0] // Expand;
     err = err + temp[1]*temp[1];];];
   ErrB2[m] = err/(M + 1)/(M + 1) // Together;];
(*errb ends*)

(*Pade for sigma1*)
hpw[F_, m_, n_] := Block[{i, k, dF, temp, q}, dF[0] = F[0];
   For[k = 1, k <= m + n, k = k + 1, 
    dF[k] = Expand[F[k] - F[k - 1]]];
   temp = dF[0] + Sum[dF[i]*q^i, {i, 1, m + n}] // Expand // check;
   hpw[m, n] = PadeApproximant[temp, {q, 0, {m, n}}] /. q -> 1];

GetAw[m_, Num_] := Module[{temp, i, j},
   For[i = 1, i <= Num, i = i + 1, 
    For[j = -Num, j <= Num, j = j + 1, 
      Aw[i, j, m] = 
        Coefficient[eta[m], Cos[i*x1 + j*x2]] // Expand;];];
   For[j = 1, j <= Num, j = j + 1, 
    Aw[0, j, m] = Coefficient[eta[m], Cos[j*x2]] // Expand;];
   Aw[0, 0, m] = eta[m] /. Cos[_] -> 0;];


GetHPA[m_, n_, Num_] := 
  Module[{temp, i, j},(*Num\[LessEqual]m+n*)
   Print["Pade a , m=", m, ", n=", n];
   For[i = 0, i <= m + n, i = i + 1, GetAw[i, Num];];
   
   temp = Aw[0, 0, 0] + Sum[Aw[0, 0, p]*qq^p, {p, 1, m + n}];
   a[0, 0] = PadeApproximant[temp, {qq, 0, {m, n}}] /. qq -> 1;
   
   For[j = 1, j <= Num, j = j + 1,(*Print["i=",i,",j=",j];*)
    temp = Aw[0, j, 0] + Sum[Aw[0, j, p]*qq^p, {p, 1, m + n}];
    a[0, j] = PadeApproximant[temp, {qq, 0, {m, n}}] /. qq -> 1];
   
   a[1, 0] = A0;
   
   For[j = -Num, j <= -1, j = j + 1,(*Print["i=",i,",j=",j];*)
    temp = Aw[1, j, 0] + Sum[Aw[1, j, p]*qq^p, {p, 1, m + n}];
    a[1, j] = PadeApproximant[temp, {qq, 0, {m, n}}] /. qq -> 1];
   
   For[j = 1, j <= Num, j = j + 1,(*Print["i=",i,",j=",j];*)
    temp = Aw[1, j, 0] + Sum[Aw[1, j, p]*qq^p, {p, 1, m + n}];
    a[1, j] = PadeApproximant[temp, {qq, 0, {m, n}}] /. qq -> 1];
   
   For[i = 2, i <= Num, i = i + 1, 
    For[j = -Num, j <= Num, j = j + 1, 
      temp = Aw[i, j, 0] + Sum[Aw[i, j, p]*qq^p, {p, 1, m + n}];
      a[i, j] = 
       PadeApproximant[temp, {qq, 0, {m, n}}] /. qq -> 1];];];

GetDisHP[Num_] := 
  Module[{temp, i, j}, 
   temp[0] = 
    a[0, 0]^2 + Sum[a[i, j]^2, {i, 1, Num}, {j, -Num, Num}] + 
     Sum[a[0, j]^2, {j, 1, Num}];
   Print["total E = ", temp[0]// N ];
   (*dis[0, 0] = a[0, 0]^2/temp[0];
   If[dis[0, 0] > 10^(-3), 
    Print["dis[", 0, ",", 0, "] = ", dis[0, 0] // N]];*)

   For[i = 1, i <= Num, i = i + 1, 
    For[j = -Num, j <= Num, j = j + 1, dis[i, j] = a[i, j]^2/temp[0];
      If[dis[i, j] > 10^(-3), 
       Print["dis[", i, ",", j, "] = ", dis[i, j] // N]];];];

   For[j = 1, j <= Num, j = j + 1, dis[0, j] = a[0, j]^2/temp[0];
    If[dis[0, j] > 10^(-3), 
     Print["dis[", 0, ",", j, "] = ", dis[0, j] // N]];];];

(************************************************************************)
(*energy distribution*)(*2022.6.28*)
(************************************************************************)
GetHPE[m_, n_, Num_] := Module[{temp, i, j},
   For[i = 0, i <= m + n, i = i + 1, GetAw[i, Num];];
   temp = Aw[0, 0, 0] + Sum[Aw[0, 0, p]*1^p, {p, 1, m + n}];
   e[0, 0] = temp;
   For[j = 1, j <= Num, j = j + 1,(*Print["i=",i,",j=",j];*)
    temp = Aw[0, j, 0] + Sum[Aw[0, j, p]*1^p, {p, 1, m + n}];
    e[0, j] = temp];
   e[1, 0] = A0;
   For[j = -Num, j <= -1, j = j + 1,(*Print["i=",i,",j=",j];*)
    temp = Aw[1, j, 0] + Sum[Aw[1, j, p]*1^p, {p, 1, m + n}];
    e[1, j] = temp];
   For[j = 1, j <= Num, j = j + 1,(*Print["i=",i,",j=",j];*)
    temp = Aw[1, j, 0] + Sum[Aw[1, j, p]*1^p, {p, 1, m + n}];
    e[1, j] = temp];
   For[i = 2, i <= Num, i = i + 1, 
    For[j = -Num, j <= Num, j = j + 1, 
      temp = Aw[i, j, 0] + Sum[Aw[i, j, p]*1^p, {p, 1, m + n}];
      e[i, j] = temp];];];

GetDisE[Num_] := 
  Module[{temp, i, j}, 
   temp[0] = 
    e[0, 0]^2 + Sum[e[i, j]^2, {i, 1, Num}, {j, -Num, Num}] + 
     Sum[e[0, j]^2, {j, 1, Num}];
   dise[0, 0] = e[0, 0]^2/temp[0];
   If[dise[0, 0] > 10^(-3), 
    Print["dise[", 0, ",", 0, "] = ", dise[0, 0] // N]];
   For[i = 1, i <= Num, i = i + 1, 
    For[j = -Num, j <= Num, j = j + 1, dise[i, j] = e[i, j]^2/temp[0];
      If[dise[i, j] > 10^(-3), 
       Print["dise[", i, ",", j, "] = ", dise[i, j] // N]];];];
   For[j = 1, j <= Num, j = j + 1, dise[0, j] = e[0, j]^2/temp[0];
    If[dise[0, j] > 10^(-3), 
     Print["dise[", 0, ",", j, "] = ", dise[0, j] // N]];];];
